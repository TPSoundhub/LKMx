# Tonegen w sample KB.py
#
# Programme that generates tones from a sample recording. Here a tap on a glass bowl. Tones for a musical scale
# are generated by pitch shifting the sound.
#
# Tones are then mapped to Keyboard so it can be used as a 'piano' Other sensors to be used as input later on.
#
# Revision 0.4 - 20Jan2020 - Knud Funch, Soundhub danmark - LYDKit til undevisningbrug - Region MidtJylland
# To be used as input for Workshop 19/2-2020 with teachers as preparation for debate on coupling to Physics/Math class
#
# To be run from within Thonny IDE on both PC and PI.
# As precondition the following libraries needs to be included in IDE - That is to be installed via TOOLS/MANAGE PACKAGES
# from within Thonny.
#
#         - numpy
#         - matplotliob
#         - scipy
#         - pygame - which already should be in place due to project 2019
#
# The part mapping tones to keyboard and plot's a sample tone is identical to the twin program "Tonegen w sample KB.py"
# both located on GITHUB
#
# When running the program first a plot is made, and you must quit that by pressing the X in upper right corner before
# you get to the piano part - able to play tones by pressing keys on the keyboard.
#
# You must have focus in the small 'black' window to get keys into this program.
#  
# To shut down program and get window cleared you must either press ESC or the X in upper right corner.


from scipy.io import wavfile
import numpy as np
import pygame

# To make a plot of tone and spectrum the below is imported.
# if you remove test plot code then you do not need to improt these hence do not need them in environment
# that is to include package via Tools in Thonny
#
import matplotlib.pyplot as plt
from scipy.fftpack import fft,fftfreq


#
# The sound file that makes the starting point for the scale.
# a sample sound (recorded) from a glass bowl beeing tapped
#
sf, sound = wavfile.read('bowl.wav')
print("lenght of sound: ", len(sound))
print("samples pr second",sf)

#
# A rough test of plotting. Not needed for generating sound!
# Needs more work for better readability - get axis correct etc.
#
def plot_tone_and_spectrum(x):  # more work to make it more readable - axis time in ms etc...! dB scale for intensity ....
    plt.subplot(121)
    plt.axis([0,int(sf/50),-20000,20000])   # one 50th of a sec (20ms) samples in time and +/- 20000 in amp
    plt.plot(x)
    FFT = abs(fft(x))
    freqs = fftfreq(x.size, 1/sf)
    plt.subplot(122)
    plt.axis([0,2000,5,10])            # only positive below 2000 Hz and amp above 5 in log10
    plt.plot(freqs,np.log10(FFT))
    plt.show()

#
# The key functions that needs to be understood/explanied math wise are below
# - speedx
# - stretch
# - pitchshift that use the other 2 and are the central one taking the one sound and map is to a scale
#
# Works with mono file as in this ex. What about stereo?
#
def speedx(snd_array, factor):
    """ Speeds up / slows down a sound, by some factor. """
    indices = np.round(np.arange(0, len(snd_array), factor))
    indices = indices[indices < len(snd_array)].astype(int)
    return snd_array[indices]


def stretch(snd_array, factor, window_size, h):
    """ Stretches/shortens a sound, by some factor. """
    phase = np.zeros(window_size)
    hanning_window = np.hanning(window_size)
    result = np.zeros(int(len(snd_array) / factor + window_size))

    for i in np.arange(0, len(snd_array) - (window_size + h), h*factor):
        i = int(i)
        # Two potentially overlapping subarrays
        a1 = snd_array[i: i + window_size]
        a2 = snd_array[i + h: i + window_size + h]

        # The spectra of these arrays
        s1 = np.fft.fft(hanning_window * a1)
        s2 = np.fft.fft(hanning_window * a2)

        # Rephase all frequencies
        phase = (phase + np.angle(s2/s1)) % 2*np.pi

        a2_rephased = np.fft.ifft(np.abs(s2)*np.exp(1j*phase))
        i2 = int(i/factor)
        result[i2: i2 + window_size] += hanning_window*a2_rephased.real

    # normalize (16bit)
    result = ((2**(16-4)) * result/result.max())

    return result.astype('int16')


def pitchshift(snd_array, n, window_size=2**13, h=2**11):
    """ Changes the pitch of a sound by ``n`` semitones. """
    factor = 2**(1.0 * n / 12.0)
    stretched = stretch(snd_array, 1.0/factor, window_size, h)
    return speedx(stretched[window_size:], factor)


#
#
# Generate sound array for all nodes that are to be mapped to keys on keyboard
# sound array does this with the arguments the mixer is initialised with
# Here 1 - means mono
#

pygame.mixer.init(sf, -16, 1)

tones = range(-25, 24)

print('Transponding sound file... ')
transposed_sounds = [pitchshift(sound, n) for n in tones]
print('DONE')

# Window needed for getting keyboard input to the program. (ESC stops and close window)
screen = pygame.display.set_mode((150, 150))


keys=['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', 'q', 'w', 'e', 'r',
      't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j',
      'k', 'l', ';', "'",'<', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'right shift',
      'right ctrl', 'left', 'down', 'up', 'right']

sounds = map(pygame.sndarray.make_sound, transposed_sounds)
print(sounds)

# Map keys and sounds together in dictionaty for easy and fast look up
key_sound = dict(zip(keys, sounds))
# is playing table for checking sound playing pr key - and initialise all to False (not playing)
is_playing = {k: False for k in keys}


# to illustrate a plot lets plot one of the generated tones and the spectrum - need more work
# YOU must quit the plot by X'ing the plot window before getting to the playback mode!!!
sound_to_plot = transposed_sounds[28]  # mono sound so no need to make slice  mapped to 'H' key on KB
plot_tone_and_spectrum(sound_to_plot)

# Take KB input events and play coresponding tone - you have a 'keyboard piano' now so play along ;-)
run = True
while run:
    event = pygame.event.wait()

    if event.type == pygame.QUIT: run = False  # X'ed in window
    else:
        if event.type in (pygame.KEYDOWN, pygame.KEYUP):
            key = pygame.key.name(event.key)
            print(key)
            if event.key == pygame.K_ESCAPE: run = False
            if (event.type == pygame.KEYDOWN) and (key in key_sound.keys()) and (not is_playing[key]):
                key_sound[key].play(fade_ms=50)  # fade out - natural decay
                is_playing[key] = True
            elif event.type == pygame.KEYUP and key in key_sound.keys():
                key_sound[key].fadeout(20)
                is_playing[key] = False

# When running is stopped
pygame.quit()  # clean up - removes the window for focus/KB input
